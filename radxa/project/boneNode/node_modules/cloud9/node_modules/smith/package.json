{
  "author": {
    "name": "Ajax.org B.V.",
    "email": "info@ajax.org"
  },
  "contributors": [
    {
      "name": "Tim Caswell",
      "email": "tim@c9.io"
    }
  ],
  "name": "smith",
  "description": "Smith is an RPC agent system for Node.JS used in architect and vfs.",
  "version": "0.1.21",
  "scripts": {
    "test": "./test-all.sh"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/c9/smith/raw/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/c9/smith.git"
  },
  "main": "smith.js",
  "engines": {
    "node": ">=0.6.0"
  },
  "dependencies": {
    "msgpack-js": "~0.1.0"
  },
  "readme": "# Smith\n\n[![Build Status](https://secure.travis-ci.org/c9/smith.png)](http://travis-ci.org/c9/smith)\n\nSmith is an RPC agent system for Node.JS used in architect and vfs.\n\n## Usage\n\nSmith can be used in any situation where you have a duplex node stream.  This\ncan be over tcp, stdio, a pipe, or anything that sends bytes back and forth.\n\n### TCP client-server example\n\nIn this example, I have a TCP server that serves an add function to any agent\nclients who want to consume the service.\n\nFor the server, we create a small agent and serve it on a listening tcp port.\n\n```js\nvar net = require('net');\nvar Agent = require('smith').Agent;\n\nvar api = {\n  add: function (a, b, callback) {\n    callback(null, a + b);\n  }\n};\n\n// Start a TCP server\nnet.createServer(function (socket) {\n  // Create the agent that serves the shared api.\n  var agent = new Agent(api);\n  // Connect to the remote agent\n  agent.connect(socket, function (err, api) {\n    if (err) return console.error(err.stack);\n    console.log(\"A new client connected\");\n  });\n  // Log when the agent disconnects\n  agent.on(\"disconnect\", function (err) {\n    console.error(\"The client disconnected\")\n    if (err) console.error(err.stack);\n  });\n\n}).listen(1337, function () {\n  console.log(\"Agent server listening on port 1337\");\n});\n```\n\nThen to consume this TCP service, we can create an agent and connect it to the\ntcp server.\n\n```js\nvar net = require('net');\nvar Agent = require('smith').Agent;\n\nvar socket = net.connect(1337, function () {\n  // Create our client\n  var agent = new Agent()\n  agent.connect(socket, function (err, api) {\n    api.add(4, 5, function (err, result) {\n      if (err) throw err;\n      console.log(\"4 + 5 = %s\", result);\n      agent.disconnect();\n    });\n  });\n});\n```\n\nFor an example of how to reconnect if the connection goes down, see\nhttps://github.com/c9/smith/blob/master/samples/tcp-client-autoreconnect.js\n\n### STDIO Parent-Child Example\n\nHere we create a node process that spawns a child process, and the two talk to eachother calling functions both directions.\n\nBoth share a simple API library.\n\n```js\nexports.ping = function (callback) {\n    callback(null, process.pid + \" pong\");\n}\n```\n\nThe parent creates an Agent,spawns the child, and connects.\n\n```js\nvar spawn = require('child_process').spawn;\nvar Agent = require('smith').Agent;\nvar Transport = require('smith').Transport;\n\n// Create an agent instance using the shared API\nvar agent = new Agent(require('./process-shared-api'));\n\n// Spawn the child process that runs the other half.\nvar child = spawn(process.execPath, [__dirname + \"/process-child.js\"]);\n// Forward the child's console output\nchild.stderr.pipe(process.stderr);\n\nvar transport = new Transport(child.stdout, child.stdin);\nagent.connect(transport, function (err, api) {\n  if (err) throw err;\n  // Call the child's API in a loop\n  function loop() {\n    api.ping(function (err, message) {\n      if (err) throw err;\n      console.log(\"Child says %s\", message);\n    })\n    setTimeout(loop, Math.random() * 1000);\n  }\n  loop();\n});\n```\n\nThe child resumes stdin, creates an Agent, and connects.\n\n```js\nvar Agent = require('smith').Agent;\nvar Transport = require('smith').Transport;\n\n// Redirect logs to stderr since stdout is used for data\nconsole.log = console.error;\n\n// Start listening on stdin for smith rpc data.\nprocess.stdin.resume();\n\nvar agent = new Agent(require('./process-shared-api'));\nvar transport = new Transport(process.stdin, process.stdout);\nagent.connect(transport, function (err, api) {\n  if (err) throw err;\n  // Call the parent's API in a loop\n  function loop() {\n    api.ping(function (err, message) {\n      if (err) throw err;\n      console.log(\"Got %s from parent\", message);\n    })\n    setTimeout(loop, Math.random() * 1000);\n  }\n  loop();\n});\n```\n\n## Class: Agent\n\nAgent is the main class used in smith.  It represents an agent in your mesh\nnetwork.  It provides a set of service functions exposed as async functions.\n\n### new Agent(api)\n\nCreate a new Agent instance that serves the functions listed in `api`.\n\n### agent.api\n\nThe functions this agent serves locally to remote agents.\n\n### agent.remoteApi\n\nA object containing proxy functions for the api functions in the remote agent.\nCalling these functions when the remote is offline will result in the last\nargument being called with a ENOTCONNECTED error (assuming it's a function).\n\n### agent.connectionTimeout\n\nIf the connection hasn't happened by 10,000 ms, an ETIMEDOUT error will\nhappen.  To change the timeoutvalue, change `connectionTimeout` on either the\ninstance or the prototype.  Set to zero to disable.\n\n### Event: 'connect'\n\n`function (remoteApi) { }`\n\nWhen the rpc handshake is complete, the agent will emit a connect event\ncontaining the remoteApi.\n\n### Event: 'disconnect'\n\n`function () { }`\n\nEmitted when the transport dies and the remote becomes offline\n\n### Event: 'drain'\n\nWhen the writable stream in the transport emits drain, it's forwarded here\n\n### agent.connect(transport, [callback]))\n\nStart the connection to a new remote agent using `transport`.  Emits `connect` when\nready or `error` on failure.  Optionally use the callback to get `(err, api,\nagent)` results.\n\nThe `transport` argument is either a Transport instance or a duplex Stream.\nThe callback will be called with `(err, remoteApi)`.\n\n### agent.disconnect(err)\n\nTell the agent to disconnect from the transport with optional error reason `err`.\n\n### agent.send(message)\n\nEncode a message and send it on the transport.  Used internally to send\nfunction calls.  Returns false if the kernel buffer is full.\n\n## Class: Transport\n\nTransport is a wrapper around a duplex socket to allow two Agent instances to\ntalk to eachother.  A transport will shut down itself if either end of the\nsocket ends and emit an `error` event.\n\n### new Transport(input, [output])\n\nPass in either a duplex Stream instance or two streams (one readable, one\nwritable).  This transport object can then be used to connect to another\nAgent.\n\n### Event: 'message'\n\n`function (message) { }`\n\nEmitted when a message arrives from the remote end of the transport.ts\n\n### Event: 'drain'\n\n`function () { }`\n\nEmitted when the writable stream emits drain. (The write buffer is empty.)\n\n### Event: 'disconnect'\n\n`function (err) { }`\n\nEmitted when the transport dies.  If this was caused by an error, it will be\nemitted here.\n\n### transport.send(message)\n\nSend a message to the other end of the transport.  Message is JSON\nserializable object with the addition of being able to serialize node Buffer\ninstances and `undefined` values.  Returns true if the kernel buffer is full\nand you should pause your incoming stream.\n",
  "readmeFilename": "README.markdown",
  "bugs": {
    "url": "https://github.com/c9/smith/issues"
  },
  "homepage": "https://github.com/c9/smith",
  "_id": "smith@0.1.21",
  "dist": {
    "shasum": "5ce35a41d12f8ca10e11abf8318831caaf6b7a9d"
  },
  "_from": "https://github.com/c9/smith/tarball/d83208007e681c147ebb12c30e09a193fd731391",
  "_resolved": "https://github.com/c9/smith/tarball/d83208007e681c147ebb12c30e09a193fd731391"
}
