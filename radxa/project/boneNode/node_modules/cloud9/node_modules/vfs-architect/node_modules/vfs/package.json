{
  "name": "vfs",
  "version": "0.0.2",
  "private": true,
  "dependencies": {
    "simple-mime": "~0.0.5",
    "smith": "~0.1.1",
    "ws": "~0.4.20"
  },
  "devDependencies": {
    "chai": "~1.2.0",
    "mocha": "~1.3.2"
  },
  "scripts": {
    "test": "git clean -df test/mock; mocha -R spec"
  },
  "readme": "# VFS - Virtual File System\n\n**This repo is being broken up into several smaller repos.  For example, see [vfs-local](https://github.com/c9/vfs-local), [vfs-socket](https://github.com/c9/vfs-socket) and [vfs-http-adapter](https://github.com/c9/vfs-http-adapter).**\n\nThis module is a vfs implementation for node.js.  Originally it was created for\nour internal needs at Cloud9IDE.  Eventually it grew to be generally useful so\nwe're releasing it here as a general purpose vfs system.\n\nThe basic use case for this system is to expose a common http friendly, streaming,\nfilesystem interface.  It's doesn't assume http and can be used in other contexts,\nbut it does provide support for http Range requests, ETag based conditional queries,\nHEAD requests, and file streaming for reading and writing.  Also it provides\nstreaming directory listing using weak ETags.\n\nAlso included is a connect/stack middleware module that allows mounting these vfs\ninstances and exposing them with a simple RESTful API.\n\n# HTTP RESTful Interface\n\nSee the docs in the http-adapter for specifics.\n\n<https://github.com/c9/vfs-http-adapter>\n\n# JavaScript Interface\n\nThe various vfs implementations all follow the same JavaScript interface so that\nthey are interchangable.\n\n## setup(options)\n\nAt the top of the module (often the module itself) is a setup function.  This\ntakes a single options object as configuration and returns a vfs instance.\n\nAvailable options vary by module.  See the indivual modules for specifics.\n\nWithin a vfs, paths are relative to that vfs and files outside that tree cannot\nbe accessed.\n\nAll functions have the same signature `(path, options, callback(err, meta){})`.\n\n`path` is always the path to the resource in question.  It's a virtual path\nrelative to the vfs instance.\n\n## vfs.readfile(path, options, callback)\n\nRead a file and stream it's contents.\n\n`options` can include:\n\n - options.etag - the browser sent an If-None-Match header with etag\n - options.head - the request was a HEAD request\n - options.range - the request had a Range header, this object can have \"start\", \"end\" and/or \"etag\".\n\n`meta` in the response can include:\n\n - meta.notModified - truthy if the server should send 304 (etag matched)\n - meta.rangeNotSatisfiable - truthy if the server should send 416\n - meta.partialContent - object if server should send 206 and contains \"start\", \"end\", and \"size\" needed for the \"Content-Range\" header.\n - meta.mime - the mime type of the file\n - meta.size - the size of the file\n - meta.etag - the etag of the file (embeds inode, size and mtime)\n - meta.stream - a readable stream if the response should have a body.\n\n## vfs.readdir(path, options, callback)\n\nRead a directory and get a listing of it's contents as JSON.  Note the stream is\na data stream (already JSON serialized), not an object stream.\n\n`options` can include:\n\n - options.etag - the browser sent an If-None-Match header with etag\n - options.head - the request was a HEAD request\n\n`meta` in the response can include:\n\n - meta.notModified - truthy if the server should send 304 (etag matched)\n - meta.etag - The weak etag of the directory (embeds inode, size and mtime)\n - meta.mime - The mime of the directory \"inode/directory\"\n - meta.stream - The json stream (unless options.head was truthy)\n\nThe format of the stream is a JSON array with an object for each entry in the\ndirectory.  Entries contain:\n\n - name: the filename\n - path: the path relative to the vfs root\n - href: a full href to the resource (useful for the jsonview plugin to enable hyperlinking)\n - mime: the mime type of the file, this includes directories, symlinks, sockets, etc..\n - access: An integer bitfield showing the access permissions of the vfs. (4 - read, 2 - write, 1 - execute/search)\n - size: The size of the file as reported by stat\n - etag: The etag of this file or directory\n - link: (optional) The data contents of a symlink if the entry is a symlink.\n\n## vfs.stat(path, options, callback)\n\nReturns the file system attributes of a directory or a file and returns it\nusing the same format as the `readdir` command.\n\n`meta` in the response can include:\n\n - meta.etag - The weak etag of the directory (embeds inode, size and mtime)\n - meta.mime - The mime of the directory \"inode/directory\"\n - name: the filename\n - path: the path relative to the vfs root\n - href: a full href to the resource (useful for the jsonview plugin to enable hyperlinking)\n - access: An integer bitfield showing the access permissions of the vfs. (4 - read, 2 - write, 1 - execute/search)\n - size: The size of the file as reported by stat\n - link: (optional) The data contents of a symlink if the entry is a symlink.\n\n## vfs.mkfile(path, options, callback)\n\nSaves a file stream to the vfs.  Always first creates a tmp file and then renames\nfor atomic writes.\n\nThere are no `options` for this function.\n\n`meta` in the response can include:\n\n - meta.stream - a writable stream to the filesystem.\n - meta.tmpPath - the actual filepath of the tmpfile\n\n\n## vfs.mkdir(path, options, callback)\n\nCreate a directory.\n\nThere are no `options` for this function.\n\n`meta` in the response is empty.\n\n## vfs.rmfile(path, options, callback)\n\nRemove a file\n\nThere are no `options` for this function.\n\n`meta` in the response is empty.\n\n## vfs.rmdir(path, options, callback)\n\nRemove a directory\n\n`options` can include:\n\n - options.recursive - (optional, default is `false`) whether to delete everything within this directory.\n\n`meta` in the response is empty.\n\n## vfs.rename(path, options, callback)\n\nRename a file or directory\n\n`options` can include:\n\n - options.from - the file we want to rename.\n\n`meta` in the response is empty.\n\n## vfs.copy(path, options, callback)\n\nCopy a file\n\n`options` can include:\n\n - options.from - the file we want to copy from.\n\n`meta` in the response is empty.\n\n## vfs.symlink(path, options, callback)\n\nCreate a symlink\n\n`options` can include:\n\n - options.target - The data contents of the symlink\n\n`meta` in the response is empty.\n\n\n\n",
  "readmeFilename": "README.markdown",
  "description": "**This repo is being broken up into several smaller repos.  For example, see [vfs-local](https://github.com/c9/vfs-local), [vfs-socket](https://github.com/c9/vfs-socket) and [vfs-http-adapter](https://github.com/c9/vfs-http-adapter).**",
  "_id": "vfs@0.0.2",
  "dist": {
    "shasum": "0c3fb656e7f452bf5aa5191e6ca885b2dee50fdd"
  },
  "_resolved": "git://github.com/c9/vfs.git#6c7249e96a5cde8b7957fbdf1cb838a9a7959afb",
  "_from": "vfs@git://github.com/c9/vfs.git#6c7249e96a5cde8b7957fbdf1cb838a9a7959afb"
}
